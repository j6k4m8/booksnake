#!/usr/bin/env python

import os
import sys
import json

import smtplib
import mimetypes
import email
import email.mime.application
try:
    import email.mime.Multipart
except:
    import email.mime.multipart

import getpass

import urllib
import time
import urllib.request
from bs4 import BeautifulSoup

import argparse
import libgenapi

settings = {}
HANDLED_FORMATS = ['mobi', 'html', 'epub']

# Uniformize 'input()'
try:
    input = raw_input
except NameError:
    pass

try:
    urlretrieve = urllib.urlretrieve
except:
    urlretrieve = urllib.request.urlretrieve

cleanups = []

Colors = {
    "red": '\033[91m',
    "green": '\033[92m',
    "yellow": '\033[93m',
    "light_purple": '\033[94m',
    "purple": '\033[95m',
    "cyan": '\033[96m',
    "end": '\033[0m'

}
def _status(msg, color="end"):
    sys.stdout.write("{}{}{}\n".format(Colors[color], msg, Colors["end"]))


def read_settings():
    """
    Read in the settings from a ~/.booksnakerc. If the file does not exist,
    then generate a new file.
    """
    global settings
    try:
        with open(os.path.expanduser('~/.booksnakerc'), 'r') as setfh:
            settings = json.load(setfh)
    except:
        _status("No .booksnakerc file found, creating a new one.", color="yellow")
        settings = {}
        save_settings()


def send_file(filename, from_email=None, to_email=None):
    # http://stackoverflow.com/a/8243031/979255
    if from_email is None:
        if 'from_email' not in settings:
            raise ValueError("No from_email supplied.")
        from_email = settings['from_email']

    if to_email is None:
        if 'to_email' not in settings:
            raise ValueError("No to_email supplied.")
        to_email = settings['to_email']

    try:
        m = email.mime.Multipart.MIMEMultipart()
    except:
        m = email.mime.multipart.MIMEMultipart()
    m['Subject'] = ''
    m['From'] = from_email
    m['To'] = to_email

    fp = open(filename, 'rb')
    att = email.mime.application.MIMEApplication(fp.read(),
                                                 _subtype="x-mobipocket-ebook")
    fp.close()
    att.add_header('Content-Disposition', 'attachment', filename=filename)
    m.attach(att)

    cleanups.append(filename)

    while True:
        try:
            if 'smtp_password' not in settings or settings['smtp_password'] in [None, ""]:
                passwd = getpass.getpass("SMTP password for {}: ".format(from_email))
            else:
                passwd = settings['smtp_password']

            _status("Beginning send...", "cyan")
            s = smtplib.SMTP('smtp.gmail.com:587')
            s.starttls()
            s.login(from_email, passwd)
            s.sendmail(
                from_email,
                [to_email],
                m.as_string())
            s.quit()
            _status("Send complete.", "cyan")
            return
        except:
            pass


def save_settings():
    """
    Write settings to ~/.booksnakerc.
    """
    with open(os.path.expanduser('~/.booksnakerc'), 'w+') as setfh:
        json.dump(settings, setfh, sort_keys=True, indent=4, ensure_ascii=False)


def convert_file(filename, ext):
    os.system('kindlegen "{}"'.format(filename))
    cleanups.append(filename)
    filename = ".".join(filename.split('.')[:-1]) + ".mobi"
    cleanups.append(filename)
    return filename


def process_file(filename):
    """
    Process a file.
    """
    filename = os.path.expanduser(filename)
    if not os.path.exists(filename):
        raise ValueError("No such file {}.".format(filename))

    ext = filename.split('.')[-1]
    if ext != 'mobi':
        # We need to convert.
        filename = convert_file(filename, ext)
    return filename


def _attempt_url(url, fmt="mobi", fname=None):
    """
    Attempts to download a file. Returns `None` if the download fails.
    """
    if fname is None:
        filename = ".booksnake_{}.{}".format(str(int(time.time())), fmt)
    else:
        filename = "{}.{}".format(fname, fmt)
    filename, _ = urlretrieve(url, filename)
    return filename

def process_url(url):
    """
    Process a url.
    """
    pass


def process_magnet(magnet):
    """
    Process a magnet.
    """
    pass


def _trunc(s, length):
    if len(s) > length:
        return s[:length - 3] + "..."
    return s


class LibreLib:
    def __init__(self):
        self.base_url = "http://www.librelib.com"

    def get_options(self, query):
        query = query.replace(' ', '+')
        query = "/book?s=" + query
        f = urllib.request.FancyURLopener({}).open(self.base_url + query)
        content = f.read()
        soup = BeautifulSoup(content, 'html.parser')
        options = [[
            a.findAll('a')[0].text.strip(),     # author
            a.findAll('a')[1].text.strip(),     # title
            a.findAll('a')[-1].text,            # format
            a.findAll('a')[-1].get('href')      # link
        ] for a in soup.findAll('tr')[1:]]
        return options


LIBRELIB = 1
LIBGEN   = 1
def process_query(query, mode=LIBRELIB):
    """
    Process a query.
    """
    ll = LibreLib()
    options = ll.get_options(query)
    select_i = 1
    for pub in options:
        print("[{}]{}\t{}\t{}\t{}".format(
            select_i,
            [" ", "*"][pub[2] == 'mobi'],
            _trunc(pub[0], 30), # author
            _trunc(pub[1], 30), # title
            pub[2], # format
        ))
        select_i += 1
    selection = input("Select the book to download (1..{}): ".format(select_i - 1))
    choice = options[int(selection) - 1]
    return _attempt_url(choice[3].replace('download', 'get'), choice[2], choice[1])

def delete_files():
    for fn in cleanups:
        try:
            os.remove(fn)
        except:
            pass

if __name__ == "__main__":
    read_settings()
    parser = argparse.ArgumentParser(description='Search and send books to Kindle.')
    parser.add_argument('--from', dest='from_email', required=False, default=None,
                        help='An authorized sender on your Amazon account.')
    parser.add_argument('--to', dest='to_email', required=False, default=None,
                        help="Your Kindle's email address (foo@free.kindle.com)")

    parser.add_argument('--keep', dest='keep_file', action='store_true')
    parser.add_argument('--no-keep', dest='keep_file', action='store_false')
    parser.set_defaults(keep_file=False)

    source_group = parser.add_mutually_exclusive_group(required=True)
    source_group.add_argument('--query', '-q', dest='query', required=False, default=None,
                        help="If you're searching for a file, the search terms.")
    source_group.add_argument('--file', '-f', dest='filename', required=False, default=None,
                        help="If you're sending a downloaded file, the filename.")
    source_group.add_argument('--url', '-u', dest='url', required=False, default=None,
                        help="If you're sending a downloadable file, the URL.")
    source_group.add_argument('--magnet', '-m', dest='magnet', required=False, default=None,
                        help="If you're downloading via a magnet link")
    args = parser.parse_args()

    if args.filename is not None:
        filename = args.filename
    elif args.url is not None:
        filename = process_url(args.url)
    elif args.magnet is not None:
        filename = process_magnet(args.magnet)
    else:
        # search if all else fails.
        filename = process_query(args.query)

    # Perform conversion, if necessary.
    process_file(filename)
    # `filename` holds the name of the file to send.
    send_file(filename, args.from_email, args.to_email)

    if not args.keep_file:
        delete_files()

    save_settings()
