import os
import sys
import json

import smtplib
import mimetypes
import email
import email.mime.application
import getpass

import urllib
import time

import argparse
import libgenapi

settings = {}
HANDLED_FORMATS = ['pdf', 'mobi', 'epub', 'html']

# Uniformize 'input()'
try:
    input = raw_input
except NameError:
    pass

try:
    urlretrieve = urllib.urlretrieve
except:
    urlretrieve = urllib.request.urlretrieve

def read_settings():
    """
    Read in the settings from a ~/.booksnakerc. If the file does not exist,
    then generate a new file.
    """
    global settings
    try:
        with open(os.path.expanduser('~/.booksnakerc'), 'r') as setfh:
            settings = json.load(setfh)
    except:
        click.secho("No .booksnakerc file found, creating a new one.", fg="yellow")
        settings = {}
        save_settings()


def send_file(filename, from_email=None, to_email=None):
    # http://stackoverflow.com/a/8243031/979255
    if from_email is None:
        if 'from_email' not in settings:
            raise ValueError("No from_email supplied.")
        from_email = settings['from_email']

    if 'smtp_password' not in settings or settings['smtp_password'] in [None, ""]:
        passwd = getpass.getpass("SMTP password for {}: ".format(from_email))
    else:
        passwd = settings['smtp_password']

    if to_email is None:
        if 'to_email' not in settings:
            raise ValueError("No to_email supplied.")
        to_email = settings['to_email']

    m = email.mime.Multipart.MIMEMultipart()
    m['Subject'] = ''
    m['From'] = from_email
    m['To'] = to_email

    fp = open(filename, 'rb')
    att = email.mime.application.MIMEApplication(fp.read(),
                                                 _subtype="x-mobipocket-ebook")
    fp.close()
    att.add_header('Content-Disposition', 'attachment', filename=filename)
    m.attach(att)

    print("Beginning send...")
    s = smtplib.SMTP('smtp.gmail.com:587')
    s.starttls()
    s.login(from_email, passwd)
    s.sendmail(
        from_email,
        [to_email],
        m.as_string())
    s.quit()
    print("Send complete.")


def save_settings():
    """
    Write settings to ~/.booksnakerc.
    """
    with open(os.path.expanduser('~/.booksnakerc'), 'w+') as setfh:
        json.dump(settings, setfh, sort_keys=True, indent=4, ensure_ascii=False)


def convert_file(filename, ext):
    return filename


def process_file(filename):
    """
    Process a file.
    """
    filename = os.path.expanduser(filename)
    if not os.path.exists(filename):
        raise ValueError("No such file {}.".format(filename))

    ext = filename.split('.')[-1]
    if ext != 'mobi':
        # We need to convert.
        filename = convert_file(filename, ext)
    return filename


def _attempt_url(url, fmt="mobi", fname=None):
    """
    Attempts to download a file. Returns `None` if the download fails.
    """
    if fname is None:
        filename = ".booksnake_{}.{}".format(str(int(time.time())), fmt)
    else:
        filename = "{}.{}".format(fname, fmt)
    filename, _ = urlretrieve(url, filename)
    return filename

def process_url(url):
    """
    Process a url.
    """
    pass


def process_magnet(magnet):
    """
    Process a magnet.
    """
    pass


def _trunc(s, length):
    if len(s) > length:
        return s[:length - 3] + "..."
    return s

def process_query(query):
    """
    Process a query.
    """
    lg = libgenapi.Libgenapi(["http://libgen.io"])
    selected = 1
    options = []
    for pub in lg.search(query):
        if pub['extension'] in HANDLED_FORMATS:
            print("[{}] {}\t{}".format(
                selected,
                _trunc(pub['author'], 30),
                _trunc(pub['title'], 30)
            ))
            selected += 1
            options.append(pub)
    selection = input("Select the book to download (1..{}): ".format(selected - 1))
    selected = options[int(selection) - 1]
    return _attempt_url(selected['mirrors'][0], selected['extension'], selected['title'])


def delete_file(filename):
    os.remove(filename)

if __name__ == "__main__":
    read_settings()
    parser = argparse.ArgumentParser(description='Search and send books to Kindle.')
    parser.add_argument('--from', dest='from_email', required=False, default=None,
                        help='An authorized sender on your Amazon account.')
    parser.add_argument('--to', dest='to_email', required=False, default=None,
                        help="Your Kindle's email address (foo@free.kindle.com)")

    parser.add_argument('--keep', dest='keep_file', action='store_true')
    parser.add_argument('--no-keep', dest='keep_file', action='store_false')
    parser.set_defaults(keep_file=False)

    source_group = parser.add_mutually_exclusive_group(required=True)
    source_group.add_argument('--query', '-q', dest='query', required=False, default=None,
                        help="If you're searching for a file, the search terms.")
    source_group.add_argument('--file', '-f', dest='filename', required=False, default=None,
                        help="If you're sending a downloaded file, the filename.")
    source_group.add_argument('--url', '-u', dest='url', required=False, default=None,
                        help="If you're sending a downloadable file, the URL.")
    source_group.add_argument('--magnet', '-m', dest='magnet', required=False, default=None,
                        help="If you're downloading via a magnet link")
    args = parser.parse_args()

    if args.filename is not None:
        filename = process_file(args.filename)
    elif args.url is not None:
        filename = process_url(args.url)
    elif args.magnet is not None:
        filename = process_magnet(args.magnet)
    else:
        # search if all else fails.
        filename = process_query(args.query)

    # `filename` holds the name of the file to send.

    send_file(filename, args.from_email, args.to_email)

    if not args.keep_file:
        delete_file(filename)

    save_settings()
